import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:by_faith/app/i18n/strings.g.dart';
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import 'package:archive/archive_io.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:by_faith/objectbox.dart';
import 'package:by_faith/core/models/user_preferences_model.dart';
import '../providers/home_settings_font_provider.dart';
import 'package:bible_parser_flutter/bible_parser_flutter.dart' as bp;
import 'package:by_faith/features/study/models/study_bibles_model.dart' as study_models;
import 'package:xml/xml.dart' as xml;
import 'package:by_faith/objectbox.g.dart'; // Generated by ObjectBox
import 'package:flutter/foundation.dart'; // For compute
import 'package:flutter/services.dart'; // Required for BackgroundIsolateBinaryMessenger

class HomeSettingsScreen extends StatefulWidget {
  const HomeSettingsScreen({super.key});

  @override
  _HomeSettingsScreenState createState() => _HomeSettingsScreenState();
}

class _HomeSettingsScreenState extends State<HomeSettingsScreen> {
  late Locale _selectedLanguage;
  bool _isBiblesInstalledExpanded = false;
  List<study_models.BibleVersion> _installedBibles = [];
  bool _isLoading = false;
  String _loadingMessage = '';
  String? _uploadedFilePath;
  bool _showInstallButton = false;

  @override
  void initState() {
    super.initState();
    _loadInstalledBibles();
    // Load language preference from ObjectBox
    final prefs = getUserPreferences(userPreferencesBox);
    _selectedLanguage = Locale(prefs.languageCode ?? 'en');
  }

  void _loadInstalledBibles() {
    final bibleVersionBox = store.box<study_models.BibleVersion>();
    setState(() {
      _installedBibles = bibleVersionBox.getAll();
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _selectedLanguage = TranslationProvider.of(context).locale.flutterLocale;
  }

  void _deleteBible(study_models.BibleVersion bible) {
    final t = Translations.of(context);
    final bibleVersionBox = store.box<study_models.BibleVersion>();
    final bookBox = store.box<study_models.Book>();
    final chapterBox = store.box<study_models.Chapter>();
    final verseBox = store.box<study_models.Verse>();

    // Delete associated books, chapters, and verses
    for (final book in bible.books) {
      for (final chapter in book.chapters) {
        for (final verse in chapter.verses) { // Corrected from chapter.chapters to chapter.verses
          verseBox.remove(verse.id);
        }
        chapterBox.remove(chapter.id);
      }
      bookBox.remove(book.id);
    }
 
    final prefs = getUserPreferences(userPreferencesBox);
    if (prefs.currentBibleVersionId == bible.id) {
      prefs.currentBibleVersionId = null;
      userPreferencesBox.put(prefs);
    }

    bibleVersionBox.remove(bible.id);
    _loadInstalledBibles(); // Refresh the list
    _showSnackBar(t.home_settings_screen.bible_deleted.replaceAll('{name}', bible.name));
  }

  Future<void> _selectBibleZipFile() async {
    final t = Translations.of(context);
    setState(() {
      _isLoading = true;
      _loadingMessage = t.home_settings_screen.preparing_upload;
      _uploadedFilePath = null; // Clear previous selection
      _showInstallButton = false; // Hide install button initially
    });
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['zip'],
      );

      if (result != null && result.files.single.path != null) {
        String? filePath = result.files.single.path;
        if (filePath == null) {
          _showSnackBar(t.home_settings_screen.file_not_selected);
          return;
        }

        File file = File(filePath);
        if (!file.existsSync()) {
          _showSnackBar(t.home_settings_screen.file_not_found);
          return;
        }

        if (!filePath.toLowerCase().endsWith('.zip')) {
          _showSnackBar(t.home_settings_screen.not_a_zip_file);
          return;
        }

        setState(() {
          _uploadedFilePath = filePath; // Store the full path for installation
          _showInstallButton = true; // Show the install button
          _loadingMessage = t.home_settings_screen.file_selected;
        });
        _showSnackBar(t.home_settings_screen.file_selected_success.replaceAll('{name}', p.basename(filePath)));
      } else {
        _showSnackBar(t.home_settings_screen.file_not_selected);
      }
    } catch (e) {
      _showSnackBar('${t.home_settings_screen.upload_failed}: $e');
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  Future<void> _installSelectedBible() async {
    final t = Translations.of(context);
    if (_uploadedFilePath == null) {
      _showSnackBar(t.home_settings_screen.no_file_to_install);
      return;
    }

    setState(() {
      _isLoading = true;
      _loadingMessage = t.home_settings_screen.extracting_and_parsing;
    });

    try {
final Map<String, dynamic> parsedData = await compute(
        _extractAndParseBibleData,
        {
          'filePath': _uploadedFilePath!,
          'rootIsolateToken': RootIsolateToken.instance,
        },
      );

      if (parsedData['error'] != null) {
        _showSnackBar('${t.home_settings_screen.install_failed}: ${parsedData['error']}');
        return;
      }

      final String? usfxXmlContent = parsedData['xmlContent'];
      final String? bibleName = parsedData['bibleName'];
      final String? languageCode = parsedData['languageCode'];

      if (usfxXmlContent != null && bibleName != null && languageCode != null) {
        setState(() {
          _loadingMessage = t.home_settings_screen.saving_to_database;
        });

        final bibleVersionBox = store.box<study_models.BibleVersion>();
        final bookBox = store.box<study_models.Book>();
        final chapterBox = store.box<study_models.Chapter>();
        final verseBox = store.box<study_models.Verse>();

        // Check if a Bible with the same language code and name already exists
        study_models.BibleVersion? existingVersion = bibleVersionBox
            .query(BibleVersion_.languageCode.equals(languageCode)
                .and(BibleVersion_.name.equals(bibleName)))
            .build()
            .findFirst();

        if (existingVersion != null) {
          _showSnackBar(t.home_settings_screen.bible_already_exists.replaceAll('{name}', bibleName));
          await Directory(parsedData['extractPath']).delete(recursive: true); // Clean up temporary files
          return;
        }

        final newBibleVersion = study_models.BibleVersion(
          name: bibleName,
          languageCode: languageCode,
        );
        bibleVersionBox.put(newBibleVersion);

        final parser = bp.BibleParser(usfxXmlContent);
        final allBooks = await parser.books.toList();
        final allVerses = await parser.verses.toList();

        for (final parsedBook in allBooks) {
          final newBook = study_models.Book(name: parsedBook.title, bookId: parsedBook.id);
          newBook.bibleVersion.target = newBibleVersion;
          bookBox.put(newBook);

          final versesForBook = allVerses.where((v) => v.bookId == parsedBook.id).toList();
          final Map<int, List<bp.Verse>> versesByChapter = {};
          for (final verse in versesForBook) {
            versesByChapter.putIfAbsent(verse.chapterNum, () => []).add(verse);
          }

          for (final chapterNumber in versesByChapter.keys.toList()..sort()) {
            final newChapter = study_models.Chapter(chapterNumber: chapterNumber);
            newChapter.book.target = newBook;
            chapterBox.put(newChapter);

            for (final parsedVerse in versesByChapter[chapterNumber]!) {
              final newVerse = study_models.Verse(verseNumber: parsedVerse.num, text: parsedVerse.text);
              newVerse.chapter.target = newChapter;
              verseBox.put(newVerse);
            }
          }
        }

        // Set the newly uploaded Bible as the current one
        final prefs = getUserPreferences(userPreferencesBox);
        prefs.currentBibleVersionId = newBibleVersion.id;
        userPreferencesBox.put(prefs);

        _showSnackBar(t.home_settings_screen.install_success);
        setState(() {
          _uploadedFilePath = null; // Clear the path after successful install
          _showInstallButton = false; // Hide the install button
        });
      } else {
        _showSnackBar(t.home_settings_screen.no_xml_found);
      }
      await Directory(parsedData['extractPath']).delete(recursive: true); // Clean up temporary files
    } catch (e) {
      _showSnackBar('${t.home_settings_screen.install_failed}: $e');
    } finally {
      setState(() {
        _isLoading = false;
        _loadingMessage = '';
      });
      _loadInstalledBibles(); // Refresh the list after install
    }
  }

  // Top-level function for heavy lifting in a separate isolate for extraction and parsing
  static Future<Map<String, dynamic>> _extractAndParseBibleData(Map<String, dynamic> data) async {
    final String filePath = data['filePath'];
    final RootIsolateToken? rootIsolateToken = data['rootIsolateToken'];

    // Ensure the BackgroundIsolateBinaryMessenger is initialized for this isolate
    // before performing any platform-specific operations.
    if (rootIsolateToken != null) {
      BackgroundIsolateBinaryMessenger.ensureInitialized(rootIsolateToken);
    } else {
      // Fallback if token is null, though it should ideally always be provided.
      // This might still lead to issues if platform channels are used without a token.
      debugPrint('RootIsolateToken was null in isolate. Platform channels might not work.');
    }

    Directory? tempDir;
    String? extractPath;

    try {
      File file = File(filePath);
      List<int> bytes = await file.readAsBytes();
      final archive = ZipDecoder().decodeBytes(bytes);

      tempDir = await getTemporaryDirectory();
      extractPath = p.join(tempDir.path, 'bible_upload_temp');
      final extractDir = Directory(extractPath);

      if (await extractDir.exists()) {
        await extractDir.delete(recursive: true);
      }
      await extractDir.create(recursive: true);

      // Extract all XML files first
      for (final file in archive) {
        final filename = file.name;
        if (file.isFile && filename.toLowerCase().endsWith('.xml')) {
          final data = file.content as List<int>;
          final currentXmlFilePath = p.join(extractPath, filename);
          File(currentXmlFilePath)
            ..createSync(recursive: true)
            ..writeAsBytesSync(data);
        }
      }

      String? usfxXmlFilePath;
      String? metadataXmlFilePath;

      // First pass: Identify USFX and metadata XML files
      await for (final entity in extractDir.list(recursive: false, followLinks: false)) {
        if (entity is File && entity.path.toLowerCase().endsWith('.xml')) {
          final filename = p.basename(entity.path).toLowerCase();
          if (filename.contains('metadata.xml')) {
            metadataXmlFilePath = entity.path;
          }
          try {
            final xmlContent = await entity.readAsString();
            final xmlDocument = xml.XmlDocument.parse(xmlContent);
            if (xmlDocument.rootElement.name.local == 'usfx') {
              usfxXmlFilePath = entity.path;
            }
          } catch (e) {
            // Ignore parsing errors for non-USFX XML files or malformed XML
          }
        }
      }

      if (usfxXmlFilePath != null) {
        final xmlContent = await File(usfxXmlFilePath).readAsString();
        final xmlDocument = xml.XmlDocument.parse(xmlContent);
        final usfxElement = xmlDocument.rootElement;

        String bibleName = usfxElement.getAttribute('name') ?? p.basenameWithoutExtension(usfxXmlFilePath);
        final languageCode = usfxElement.getAttribute('lang') ?? 'en';

        // Try to get a more descriptive name from the metadata.xml file if available
        if (metadataXmlFilePath != null) {
          try {
            final metadataXmlContent = await File(metadataXmlFilePath).readAsString();
            final metadataXmlDocument = xml.XmlDocument.parse(metadataXmlContent);
            final nameElement = metadataXmlDocument.findAllElements('name').firstWhere(
              (element) => (element.parent is xml.XmlElement) && (element.parent as xml.XmlElement).name.local == 'identification',
              orElse: () => metadataXmlDocument.findAllElements('title').firstOrNull ?? xml.XmlElement(xml.XmlName('name')),
            );
            if (nameElement.innerText.isNotEmpty) {
              bibleName = nameElement.innerText;
            }
          } catch (e) {
            // Ignore errors if metadata.xml is malformed or name not found
          }
        }
        return {
          'xmlContent': xmlContent,
          'bibleName': bibleName,
          'languageCode': languageCode,
          'extractPath': extractPath,
        };
      } else {
        return {'error': 'No USFX XML file found in the ZIP.', 'extractPath': extractPath};
      }
    } catch (e) {
      return {'error': e.toString(), 'extractPath': extractPath ?? p.join((await getTemporaryDirectory()).path, 'bible_upload_temp_error')};
    }
  }

  void _showSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        duration: const Duration(seconds: 3),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final t = Translations.of(context);
    return Scaffold(
      appBar: AppBar(title: Text(t.home_settings_screen.title)),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          if (_isLoading)
            Padding(
              padding: const EdgeInsets.only(bottom: 16.0),
              child: Column(
                children: [
                  LinearProgressIndicator(),
                  SizedBox(height: 8),
                  Text(_loadingMessage),
                ],
              ),
            ),
          // Bible Settings
          Card(
            margin: const EdgeInsets.only(bottom: 16),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(t.home_settings_screen.bible_settings, style: Theme.of(context).textTheme.titleLarge),
                  const SizedBox(height: 16),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(t.home_settings_screen.bible_install, style: Theme.of(context).textTheme.titleMedium),
                        const SizedBox(height: 10),
                        TextField(
                          controller: TextEditingController(text: _uploadedFilePath != null ? p.basename(_uploadedFilePath!) : ''),
                          readOnly: true,
                          decoration: InputDecoration(
                            labelText: t.home_settings_screen.uploaded_file,
                            border: OutlineInputBorder(),
                          ),
                        ),
                        const SizedBox(height: 10),
                        ElevatedButton.icon(
                          onPressed: _selectBibleZipFile,
                          icon: const Icon(Icons.cloud_upload),
                          label: Text(t.home_settings_screen.upload_bible),
                        ),
                        if (_showInstallButton) ...[
                          const SizedBox(height: 10),
                          ElevatedButton.icon(
                            onPressed: _installSelectedBible,
                            icon: const Icon(Icons.install_desktop),
                            label: Text(t.home_settings_screen.install_bible),
                          ),
                        ],
                      ],
                    ),
                  ),
                  ExpansionTile(
                    title: Text(t.home_settings_screen.bible_download),
                    leading: const Icon(Icons.download),
                    children: [
                      Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(t.home_settings_screen.download_instructions), // Add this translation key
                            // TODO: Implement Bible Download functionality
                          ],
                        ),
                      ),
                    ],
                  ),
                  ExpansionTile(
                    title: Text(t.home_settings_screen.bibles_installed),
                    leading: const Icon(Icons.menu_book),
                    initiallyExpanded: _isBiblesInstalledExpanded,
                    onExpansionChanged: (bool expanded) {
                      setState(() {
                        _isBiblesInstalledExpanded = expanded;
                      });
                    },
                    children: [
                      _installedBibles.isEmpty
                          ? Padding(
                                padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                                child: Text(t.home_settings_screen.no_bibles_installed),
                              )
                          : Column(
                                children: _installedBibles.map((bible) => ListTile(
                                      title: Text(bible.name),
                                      subtitle: Text(bible.languageCode),
                                      trailing: IconButton(
                                        icon: const Icon(Icons.delete),
                                        tooltip: t.home_settings_screen.delete_bible,
                                        onPressed: () => _confirmAndDeleteBible(bible),
                                      ),
                                    )).toList(),
                              ),
                    ],
                  ),
                ],
              ),
            ),
          ),

          // Text Settings
          Card(
            margin: const EdgeInsets.only(bottom: 16),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(t.home_settings_screen.text_settings, style: Theme.of(context).textTheme.titleLarge),
                  const SizedBox(height: 16),
                  ListTile(
                    title: Text(t.home_settings_screen.font_family),
                    subtitle: const Text('Roboto'), // Placeholder
                    trailing: const Icon(Icons.arrow_drop_down),
                    onTap: () {
                      // TODO: Implement Font Family selection
                    },
                  ),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(t.home_settings_screen.font_size),
                        Slider(
                          value: 16, // Placeholder
                          min: 10,
                          max: 30,
                          divisions: 20,
                          label: '16', // Placeholder
                          onChanged: (double value) {
                            // TODO: Implement Font Size change
                          },
                        ),
                        Text(t.home_settings_screen.preview),
                        const Text(
                          'For God so loved the world, that he gave his only begotten Son, that whosoever believeth in him should not perish, but have everlasting life.',
                          style: TextStyle(fontSize: 16), // Placeholder
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),

          // Global Settings
          Card(
            margin: const EdgeInsets.only(bottom: 16),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(t.home_settings_screen.global_settings, style: Theme.of(context).textTheme.titleLarge),
                  const SizedBox(height: 16),
                  Text(t.home_settings_screen.language_settings, style: Theme.of(context).textTheme.titleMedium),
                  ListTile(
                    title: Text(t.home_settings_screen.app_language),
                    subtitle: Text(_selectedLanguage.languageCode == 'en' ? 'English' : _selectedLanguage.languageCode == 'es' ? 'Spanish' : 'Hindi'), // Display current language
                    trailing: DropdownButton<Locale>(
                      value: _selectedLanguage,
                      onChanged: (Locale? newLocale) {
                        if (newLocale != null) {
                          setState(() {
                            _selectedLanguage = newLocale;
                            LocaleSettings.setLocale(AppLocale.values.firstWhere((e) => e.flutterLocale == newLocale));
                            // Save language preference to ObjectBox
                            final prefs = getUserPreferences(userPreferencesBox);
                            prefs.languageCode = newLocale.languageCode;
                            userPreferencesBox.put(prefs);
                          });
                        }
                      },
                      items: AppLocaleUtils.supportedLocales.map<DropdownMenuItem<Locale>>((Locale locale) {
                        return DropdownMenuItem<Locale>(
                          value: locale,
                          child: Text(locale.languageCode == 'en' ? 'English' : locale.languageCode == 'es' ? 'Spanish' : 'Hindi'),
                        );
                      }).toList(),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _confirmAndDeleteBible(study_models.BibleVersion bible) {
    final t = Translations.of(context);
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(t.home_settings_screen.confirm_delete_title),
          content: Text(t.home_settings_screen.confirm_delete_message.replaceAll('{name}', bible.name)),
          actions: <Widget>[
            TextButton(
              child: Text(t.home_settings_screen.cancel),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: Text(t.home_settings_screen.delete),
              onPressed: () {
                _deleteBible(bible);
                Navigator.of(context).pop();
              },
            ),
          ],
        );
      },
    );
  }
}