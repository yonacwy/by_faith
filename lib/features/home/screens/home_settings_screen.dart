import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:by_faith/app/i18n/strings.g.dart';
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import 'package:archive/archive_io.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'package:by_faith/objectbox.dart';
import 'package:by_faith/core/models/user_preferences_model.dart';
import '../providers/home_settings_font_provider.dart';
import 'package:bible_parser_flutter/bible_parser_flutter.dart' as bp;
import 'package:by_faith/features/study/models/study_bibles_model.dart' as study_models;
import 'package:xml/xml.dart' as xml;
import 'package:by_faith/objectbox.g.dart'; // Generated by ObjectBox

class HomeSettingsScreen extends StatefulWidget {
  const HomeSettingsScreen({super.key});

  @override
  _HomeSettingsScreenState createState() => _HomeSettingsScreenState();
}

class _HomeSettingsScreenState extends State<HomeSettingsScreen> {
  late Locale _selectedLanguage;
  bool _isBiblesInstalledExpanded = false;
  List<study_models.BibleVersion> _installedBibles = [];

  @override
  void initState() {
    super.initState();
    _loadInstalledBibles();
    // Load language preference from ObjectBox
    final prefs = getUserPreferences(userPreferencesBox);
    _selectedLanguage = Locale(prefs.languageCode ?? 'en');
  }

  void _loadInstalledBibles() {
    final bibleVersionBox = store.box<study_models.BibleVersion>();
    setState(() {
      _installedBibles = bibleVersionBox.getAll();
    });
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _selectedLanguage = TranslationProvider.of(context).locale.flutterLocale;
  }

  void _deleteBible(study_models.BibleVersion bible) {
    final t = Translations.of(context);
    final bibleVersionBox = store.box<study_models.BibleVersion>();
    final bookBox = store.box<study_models.Book>();
    final chapterBox = store.box<study_models.Chapter>();
    final verseBox = store.box<study_models.Verse>();

    // Delete associated books, chapters, and verses
    for (final book in bible.books) {
      for (final chapter in book.chapters) {
        for (final verse in chapter.verses) { // Corrected from chapter.chapters to chapter.verses
          verseBox.remove(verse.id);
        }
        chapterBox.remove(chapter.id);
      }
      bookBox.remove(book.id);
    }

    bibleVersionBox.remove(bible.id);
    _loadInstalledBibles(); // Refresh the list
    _showSnackBar(t.home_settings_screen.bible_deleted.replaceAll('{name}', bible.name));
  }

  Future<void> _pickAndExtractAndParseBibleZipFile() async {
    final t = Translations.of(context);
    try {
      FilePickerResult? result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['zip'],
      );

      if (result != null && result.files.single.path != null) {
        String? filePath = result.files.single.path;
        if (filePath == null) {
          _showSnackBar(t.home_settings_screen.file_not_selected);
          return;
        }

        File file = File(filePath);
        if (!file.existsSync()) {
          _showSnackBar(t.home_settings_screen.file_not_found);
          return;
        }

        if (!filePath.toLowerCase().endsWith('.zip')) {
          _showSnackBar(t.home_settings_screen.not_a_zip_file);
          return;
        }

        List<int> bytes = await file.readAsBytes();
        final archive = ZipDecoder().decodeBytes(bytes);

        final tempDir = await getTemporaryDirectory();
        final extractPath = p.join(tempDir.path, 'bible_upload_temp');
        final extractDir = Directory(extractPath);

        if (await extractDir.exists()) {
          await extractDir.delete(recursive: true);
        }
        await extractDir.create(recursive: true);

        // Extract all XML files first
        for (final file in archive) {
          final filename = file.name;
          if (file.isFile && filename.toLowerCase().endsWith('.xml')) {
            final data = file.content as List<int>;
            final currentXmlFilePath = p.join(extractPath, filename);
            File(currentXmlFilePath)
              ..createSync(recursive: true)
              ..writeAsBytesSync(data);
          }
        }

        String? usfxXmlFilePath;
        // Now, iterate through extracted XML files to find the USFX one
        await for (final entity in extractDir.list(recursive: false, followLinks: false)) {
          if (entity is File && entity.path.toLowerCase().endsWith('.xml')) {
            try {
              final xmlContent = await entity.readAsString();
              final xmlDocument = xml.XmlDocument.parse(xmlContent);
              if (xmlDocument.rootElement.name.local == 'usfx') {
                usfxXmlFilePath = entity.path;
                break; // Found the USFX file, no need to check further
              }
            } catch (e) {
              // Ignore parsing errors for non-USFX XML files or malformed XML
            }
          }
        }

        if (usfxXmlFilePath != null) {
          final xmlContent = await File(usfxXmlFilePath).readAsString();
          final xmlDocument = xml.XmlDocument.parse(xmlContent);
          final usfxElement = xmlDocument.rootElement; // Confirmed to be 'usfx' by the loop above

          final bibleName = usfxElement.getAttribute('name') ?? 'Unknown Bible';
          final languageCode = usfxElement.getAttribute('lang') ?? 'en';

          final bibleVersionBox = store.box<study_models.BibleVersion>();
          final bookBox = store.box<study_models.Book>();
          final chapterBox = store.box<study_models.Chapter>();
          final verseBox = store.box<study_models.Verse>();

          // Check if a Bible with the same language code and name already exists
          study_models.BibleVersion? existingVersion = bibleVersionBox
              .query(BibleVersion_.languageCode.equals(languageCode)
                  .and(BibleVersion_.name.equals(bibleName)))
              .build()
              .findFirst();

          if (existingVersion != null) {
            _showSnackBar(t.home_settings_screen.bible_already_exists.replaceAll('{name}', bibleName));
            await extractDir.delete(recursive: true);
            return;
          }

          final newBibleVersion = study_models.BibleVersion(
            name: bibleName,
            languageCode: languageCode,
          );
          bibleVersionBox.put(newBibleVersion);

          final parser = bp.BibleParser(xmlContent);
          final allBooks = await parser.books.toList();
          final allVerses = await parser.verses.toList();

          for (final parsedBook in allBooks) {
            final newBook = study_models.Book(name: parsedBook.title, bookId: parsedBook.id);
            newBook.bibleVersion.target = newBibleVersion;
            bookBox.put(newBook);

            final versesForBook = allVerses.where((v) => v.bookId == parsedBook.id).toList();
            final Map<int, List<bp.Verse>> versesByChapter = {};
            for (final verse in versesForBook) {
              versesByChapter.putIfAbsent(verse.chapterNum, () => []).add(verse);
            }

            for (final chapterNumber in versesByChapter.keys.toList()..sort()) {
              final newChapter = study_models.Chapter(chapterNumber: chapterNumber);
              newChapter.book.target = newBook;
              chapterBox.put(newChapter);

              for (final parsedVerse in versesByChapter[chapterNumber]!) {
                final newVerse = study_models.Verse(verseNumber: parsedVerse.num, text: parsedVerse.text);
                newVerse.chapter.target = newChapter;
                verseBox.put(newVerse);
              }
            }
          }

          _showSnackBar(t.home_settings_screen.upload_success);
        } else {
          _showSnackBar(t.home_settings_screen.no_xml_found);
        }

        await extractDir.delete(recursive: true); // Clean up temporary files
      } else {
        _showSnackBar(t.home_settings_screen.file_not_selected);
      }
    } catch (e) {
      _showSnackBar('${t.home_settings_screen.upload_failed}: $e');
    }
  }

  void _showSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        duration: const Duration(seconds: 3),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final t = Translations.of(context);
    return Scaffold(
      appBar: AppBar(title: Text(t.home_settings_screen.title)),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // Bible Settings
          Card(
            margin: const EdgeInsets.only(bottom: 16),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(t.home_settings_screen.bible_settings, style: Theme.of(context).textTheme.titleLarge),
                  const SizedBox(height: 16),
                  ListTile(
                    leading: const Icon(Icons.download),
                    title: Text(t.home_settings_screen.bible_download),
                    onTap: () {
                      // TODO: Implement Bible Download functionality
                    },
                  ),
                  ListTile(
                    leading: const Icon(Icons.upload_file),
                    title: Text(t.home_settings_screen.bible_upload),
                    onTap: _pickAndExtractAndParseBibleZipFile,
                  ),
                  ExpansionTile(
                    title: Text(t.home_settings_screen.bibles_installed),
                    leading: const Icon(Icons.menu_book),
                    initiallyExpanded: _isBiblesInstalledExpanded,
                    onExpansionChanged: (bool expanded) {
                      setState(() {
                        _isBiblesInstalledExpanded = expanded;
                      });
                    },
                    children: [
                      _installedBibles.isEmpty
                          ? Padding(
                              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                              child: Text(t.home_settings_screen.no_bibles_installed),
                            )
                          : Column(
                              children: _installedBibles.map((bible) => ListTile(
                                    title: Text(bible.name),
                                    subtitle: Text(bible.languageCode),
                                    trailing: IconButton(
                                      icon: const Icon(Icons.delete),
                                      tooltip: t.home_settings_screen.delete_bible,
                                      onPressed: () => _confirmAndDeleteBible(bible),
                                    ),
                                  )).toList(),
                            ),
                    ],
                  ),
                ],
              ),
            ),
          ),

          // Text Settings
          Card(
            margin: const EdgeInsets.only(bottom: 16),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(t.home_settings_screen.text_settings, style: Theme.of(context).textTheme.titleLarge),
                  const SizedBox(height: 16),
                  ListTile(
                    title: Text(t.home_settings_screen.font_family),
                    subtitle: const Text('Roboto'), // Placeholder
                    trailing: const Icon(Icons.arrow_drop_down),
                    onTap: () {
                      // TODO: Implement Font Family selection
                    },
                  ),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(t.home_settings_screen.font_size),
                        Slider(
                          value: 16, // Placeholder
                          min: 10,
                          max: 30,
                          divisions: 20,
                          label: '16', // Placeholder
                          onChanged: (double value) {
                            // TODO: Implement Font Size change
                          },
                        ),
                        Text(t.home_settings_screen.preview),
                        const Text(
                          'For God so loved the world, that he gave his only begotten Son, that whosoever believeth in him should not perish, but have everlasting life.',
                          style: TextStyle(fontSize: 16), // Placeholder
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),

          // Global Settings
          Card(
            margin: const EdgeInsets.only(bottom: 16),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(t.home_settings_screen.global_settings, style: Theme.of(context).textTheme.titleLarge),
                  const SizedBox(height: 16),
                  Text(t.home_settings_screen.language_settings, style: Theme.of(context).textTheme.titleMedium),
                  ListTile(
                    title: Text(t.home_settings_screen.app_language),
                    subtitle: Text(_selectedLanguage.languageCode == 'en' ? 'English' : _selectedLanguage.languageCode == 'es' ? 'Spanish' : 'Hindi'), // Display current language
                    trailing: DropdownButton<Locale>(
                      value: _selectedLanguage,
                      onChanged: (Locale? newLocale) {
                        if (newLocale != null) {
                          setState(() {
                            _selectedLanguage = newLocale;
                            LocaleSettings.setLocale(AppLocale.values.firstWhere((e) => e.flutterLocale == newLocale));
                            // Save language preference to ObjectBox
                            final prefs = getUserPreferences(userPreferencesBox);
                            prefs.languageCode = newLocale.languageCode;
                            userPreferencesBox.put(prefs);
                          });
                        }
                      },
                      items: AppLocaleUtils.supportedLocales.map<DropdownMenuItem<Locale>>((Locale locale) {
                        return DropdownMenuItem<Locale>(
                          value: locale,
                          child: Text(locale.languageCode == 'en' ? 'English' : locale.languageCode == 'es' ? 'Spanish' : 'Hindi'),
                        );
                      }).toList(),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _confirmAndDeleteBible(study_models.BibleVersion bible) {
    final t = Translations.of(context);
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(t.home_settings_screen.confirm_delete_title),
          content: Text(t.home_settings_screen.confirm_delete_message.replaceAll('{name}', bible.name)),
          actions: <Widget>[
            TextButton(
              child: Text(t.home_settings_screen.cancel),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: Text(t.home_settings_screen.delete),
              onPressed: () {
                _deleteBible(bible);
                Navigator.of(context).pop();
              },
            ),
          ],
        );
      },
    );
  }
}